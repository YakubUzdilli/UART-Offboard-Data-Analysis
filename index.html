<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>UbiComp Assignment – Offboard (Streaming + Calibration)</title>
  <style>
    body{font-family:system-ui,Arial,sans-serif;max-width:900px;margin:24px auto;padding:0 16px}
    button{padding:10px 14px;margin:6px 8px 6px 0}
    #status{display:inline-block;margin-left:8px;font-weight:600}
    #sensordata{width:100%;height:70px}
    #calInfo{margin-left:8px;font-style:italic}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
  <script src="model.js"></script>
</head>
<body>
  <h1>Off-board Classification (Live Stream with Calibration)</h1>

  <p>
    <button id="btnConnect">Connect & Start Stream</button>
    <button id="btnDisconnect" disabled>Disconnect</button>
    <span id="status">Not connected</span>
  </p>

  <p>
    <button id="btnCal" disabled>Calibrate (hold still ~1s)</button>
    <span id="calInfo"></span>
  </p>

  <div id="result" style="margin-top:8px;font-weight:bold;"></div>
  <textarea id="sensordata" placeholder="Letzte CSV-Zeilen …"></textarea>
  <canvas id="myChart" style="width:100%;max-width:700px;margin-top:12px;"></canvas>

  <!-- UART.js: WebBluetooth helper -->
  <script src="https://www.espruino.com/js/uart.js"></script>
  <script>
  const $connect = document.getElementById('btnConnect');
  const $disc    = document.getElementById('btnDisconnect');
  const $status  = document.getElementById('status');
  const $sens    = document.getElementById('sensordata');
  const $result  = document.getElementById('result');
  const $cal     = document.getElementById('btnCal');
  const $calInfo = document.getElementById('calInfo');

  let connection = null;
  let lineBuf = "";
  let sampleBuf = []; // hält jeweils 60 Werte (20×x,y,z)

  // Offsets & Kalibrierung
  let ox=0, oy=0, oz=0;
  let calMode=false, calN=0, sx=0, sy=0, sz=0;

  function setConnectedUI(on){
    $connect.disabled = on;
    $disc.disabled    = !on;
    $cal.disabled     = !on;
    $status.textContent = on ? "Connected (streaming…)" : "Not connected";
    if (!on){
      $calInfo.textContent = "";
      sampleBuf=[];
    }
  }

  // ---- Plot
  let chart = null;
  function plotWindow(data){
    const xs=[], ys=[], zs=[];
    for (let i=0;i<20;i++){
      xs.push(data[3*i]);
      ys.push(data[3*i+1]);
      zs.push(data[3*i+2]);
    }
    const labels = Array.from({length:20},(_,i)=>i+1);
    if (chart) chart.destroy();
    chart = new Chart("myChart", {
      type: "line",
      data: {
        labels,
        datasets: [
          {label:"x",data:xs,fill:false,borderColor:"red"},
          {label:"y",data:ys,fill:false,borderColor:"green"},
          {label:"z",data:zs,fill:false,borderColor:"blue"}
        ]
      },
      options:{legend:{display:true}}
    });
  }

  // ---- RAW -> ±127 (±2g)
  const SCALE = 127/16384;
  function to127(v){ v = Math.round(v*SCALE); if(v>127)v=127; if(v<-127)v=-127; return v|0; }

  // ---- CSV-Zeilen aus dem Stream verarbeiten
  function handleLine(l){
    const parts = l.trim().split(",");
    if (parts.length !== 3) return;

    const x0 = to127(parseInt(parts[0],10));
    const y0 = to127(parseInt(parts[1],10));
    const z0 = to127(parseInt(parts[2],10));

    if (calMode){
      sx += x0; sy += y0; sz += z0; calN++;
    }

    // Offsets abziehen
    const x = Math.max(-127, Math.min(127, x0 - ox));
    const y = Math.max(-127, Math.min(127, y0 - oy));
    const z = Math.max(-127, Math.min(127, z0 - oz));

    sampleBuf.push(x,y,z);

    // Textfeld updaten
    const lines = $sens.value.split(/\r?\n/).slice(-8);
    lines.push(`${x},${y},${z}`);
    $sens.value = lines.join("\n");

    if (sampleBuf.length >= 60){
      const window60 = sampleBuf.slice(0,60);
      sampleBuf = sampleBuf.slice(60);

      const out = classify(window60); // aus model.js
      const labels = ["random","up-down","sideways"];
      const idx = out.indexOf(Math.max(...out));
      $result.textContent = `Classifier: ${labels[idx]}  (raw=[${out.join(", ")}])`;

      plotWindow(window60);
    }
  }

  // ---- Streaming-Code an den Puck schicken
  function sendStreamerCode(){
    const code = `
reset();
setTimeout(function(){
  var HZ=12.5, DT=80;
  Puck.accelOn(HZ);
  setInterval(function(){
    var d=Puck.accel(),a=(d&&d.acc)?d.acc:d;
    if(a) Bluetooth.println((a.x|0)+","+(a.y|0)+","+(a.z|0));
  }, DT);
  NRF.on('disconnect', function(){ reset(); });
}, 500);
`;
    connection.write("\x03" + code + "\n");
  }

  $connect.onclick = async () => {
    try{
      connection = await UART.connect();
      setConnectedUI(true);
      connection.on('data', d => {
        lineBuf += d;
        const lines = lineBuf.split(/\r?\n/);
        lineBuf = lines.pop();
        lines.forEach(handleLine);
      });
      sendStreamerCode();
    }catch(e){
      $status.textContent = "Connect failed: " + e.message;
    }
  };

  $disc.onclick = () => {
    try{ if (connection) connection.close(); }catch(_){}
    connection = null;
    setConnectedUI(false);
    lineBuf=""; sampleBuf=[];
  };

  // ---- Calibration
  $cal.onclick = () => {
    calMode = true; calN=0; sx=sy=sz=0;
    $calInfo.textContent = "Calibrating… keep still";
    setTimeout(()=>{
      if (calN>0){
        ox=Math.round(sx/calN);
        oy=Math.round(sy/calN);
        oz=Math.round(sz/calN);
        $calInfo.textContent = `Offsets set: ox=${ox}, oy=${oy}, oz=${oz}`;
      }else{
        $calInfo.textContent = "Calibration failed.";
      }
      calMode=false;
    }, 1200);
  };
  </script>
</body>
</html>
