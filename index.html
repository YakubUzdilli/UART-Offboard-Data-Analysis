<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Off-board Classification</title>
  <style>
    body{font-family:system-ui,Arial,sans-serif;max-width:900px;margin:24px auto;padding:0 16px}
    button{padding:10px 14px;margin:6px 8px 6px 0}
    label{margin-left:8px}
    #sensordata{width:100%;height:90px}
    #status{display:inline-block;margin-left:8px;font-weight:600}
    #calInfo{margin-left:8px;font-style:italic}
    canvas{max-width:700px}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
  <script src="model.js"></script>
</head>
<body>
  <h1>Off-board Classification</h1>

  <p>
    <button id="btnConnect">Connect</button>
    <button id="btnFetch" disabled>Fetch 20 samples</button>
    <label><input type="checkbox" id="autoChk" disabled /> Auto (1.6 s)</label>
    <button id="btnDisconnect" disabled>Disconnect</button>
    <span id="status">Not connected</span>
  </p>

  <p>
    <button id="btnCal" disabled>Calibrate (hold still ~1s)</button>
    <span id="calInfo"></span>
  </p>

  <textarea id="sensordata" placeholder="Letzte CSV-Zeilen …"></textarea>
  <div id="result" style="margin-top:8px;font-weight:bold;"></div>
  <canvas id="myChart"></canvas>

  <!-- UART.js (WebBluetooth helper) -->
  <script src="https://www.espruino.com/js/uart.js"></script>
  <script>
  // UI refs
  const $connect = document.getElementById('btnConnect');
  const $fetch   = document.getElementById('btnFetch');
  const $auto    = document.getElementById('autoChk');
  const $disc    = document.getElementById('btnDisconnect');
  const $status  = document.getElementById('status');
  const $sens    = document.getElementById('sensordata');
  const $result  = document.getElementById('result');
  const $cal     = document.getElementById('btnCal');
  const $calInfo = document.getElementById('calInfo');

  // State
  let connection = null;
  let autoTimer = null;
  let lineBuf = "";
  let sampleBuf = []; // hält kontinuierlich die letzten 60 Werte (20×x,y,z)

  // Kalibrierung (Offsets in ±127)
  let ox=0, oy=0, oz=0;
  let calMode=false, calN=0, sx=0, sy=0, sz=0;

  function setConnectedUI(on){
    $connect.disabled = on;
    $fetch.disabled   = !on;
    $auto.disabled    = !on;
    $disc.disabled    = !on;
    $cal.disabled     = !on;
    $status.textContent = on ? "Connected (streaming…)" : "Not connected";
    if (!on){
      $auto.checked = false;
      if (autoTimer){ clearInterval(autoTimer); autoTimer=null; }
      $calInfo.textContent = "";
      lineBuf=""; sampleBuf=[];
    }
  }

  // RAW->±127
  const SCALE = 127/16384;
  function to127(v){ v = Math.round(v*SCALE); if(v>127)v=127; if(v<-127)v=-127; return v|0; }
  function clamp127(v){ if(v>127)return 127; if(v<-127)return -127; return v|0; }

  // Plot
  let chart = null;
  function plotWindow(data){
    const xs=[], ys=[], zs=[];
    for (let i=0;i<20;i++){
      xs.push(data[3*i]);
      ys.push(data[3*i+1]);
      zs.push(data[3*i+2]);
    }
    const labels = Array.from({length:20},(_,i)=>i+1);
    if (chart) chart.destroy();
    chart = new Chart("myChart", {
      type: "line",
      data: {
        labels,
        datasets: [
          {label:"x",data:xs,fill:false,borderColor:"red"},
          {label:"y",data:ys,fill:false,borderColor:"green"},
          {label:"z",data:zs,fill:false,borderColor:"blue"}
        ]
      },
      options:{legend:{display:true}}
    });
  }

  // Zeilen aus dem Stream verarbeiten
  function handleLine(l){
    const parts = l.trim().split(",");
    if (parts.length !== 3) return;
    const x0 = to127(parseInt(parts[0],10));
    const y0 = to127(parseInt(parts[1],10));
    const z0 = to127(parseInt(parts[2],10));

    if (calMode){ sx+=x0; sy+=y0; sz+=z0; calN++; }

    // Offsets abziehen
    const x = clamp127(x0 - ox), y = clamp127(y0 - oy), z = clamp127(z0 - oz);

    // In den Ringpuffer: nur die letzten 60 Werte behalten
    sampleBuf.push(x,y,z);
    if (sampleBuf.length > 60) sampleBuf = sampleBuf.slice(sampleBuf.length-60);

    // Textarea: letzte CSV-Zeilen zeigen
    const lines = $sens.value.split(/\r?\n/).slice(-8);
    lines.push(`${x},${y},${z}`);
    $sens.value = lines.join("\n");
  }

  // Klassifikation eines 20×3 Fensters
  function classifyCurrentWindow(){
    if (sampleBuf.length < 60){
      $result.textContent = "Zu wenig Daten – kurz warten …";
      return;
    }
    const window60 = sampleBuf.slice(-60); // aktuelles Fenster
    const out = classify(window60); // aus model.js
    const labels = ["random","up-down","sideways"];
    const idx = out.indexOf(Math.max(...out));
    $result.textContent = `Classifier: ${labels[idx]}  (raw=[${out.join(", ")}])`;
    plotWindow(window60);
  }

  // Streaming-Code an den Puck schicken (läuft bis Disconnect)
  function sendStreamerCode(){
    const code = `
reset();
setTimeout(function(){
  var HZ=12.5, DT=80;
  Puck.accelOn(HZ);
  setInterval(function(){
    var d=Puck.accel(),a=(d&&d.acc)?d.acc:d;
    if(a) Bluetooth.println((a.x|0)+","+(a.y|0)+","+(a.z|0));
  }, DT);
  NRF.on('disconnect', function(){ reset(); });
}, 300);
`;
    connection.write("\x03" + code + "\n"); // Ctrl-C, dann Code
  }

  // Events
  $connect.onclick = async () => {
    try{
      // Wichtig: Espruino Web IDE muss getrennt sein.
      connection = await UART.connect();
      setConnectedUI(true);

      // Datenstrom lesen
      connection.on('data', d => {
        lineBuf += d;
        const lines = lineBuf.split(/\r?\n/);
        lineBuf = lines.pop();
        lines.forEach(handleLine);
      });

      // Stream auf dem Puck starten
      sendStreamerCode();
    }catch(e){
      $status.textContent = "Connect failed: " + e.message;
    }
  };

  $fetch.onclick = () => classifyCurrentWindow();

  $auto.onchange = () => {
    if ($auto.checked){
      autoTimer = setInterval(classifyCurrentWindow, 1600); // ~20 Samples @12.5 Hz
      classifyCurrentWindow();
    }else{
      if (autoTimer){ clearInterval(autoTimer); autoTimer=null; }
    }
  };

  $disc.onclick = () => {
    try{ if (connection) connection.close(); }catch(_){}
    connection=null;
    setConnectedUI(false);
  };

  // Kalibrierung
  $cal.onclick = () => {
    calMode = true; calN=0; sx=sy=sz=0;
    $calInfo.textContent = "Calibrating… keep still";
    setTimeout(()=>{
      if (calN>0){
        ox = Math.round(sx/calN);
        oy = Math.round(sy/calN);
        oz = Math.round(sz/calN);
        $calInfo.textContent = `Offsets set: ox=${ox}, oy=${oy}, oz=${oz}`;
      } else {
        $calInfo.textContent = "Calibration failed (no samples).";
      }
      calMode = false;
    }, 1200);
  };
  </script>
</body>
</html>
